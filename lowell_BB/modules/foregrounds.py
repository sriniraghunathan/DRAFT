import numpy as np, sys, os, scipy as sc
from scipy import interpolate as intrp
from scipy import ndimage
from pylab import *

h, k_B, c=6.626e-34,1.38e-23, 3e8
data_folder = '/Users/sraghunathan/Research/SPTPol/analysis/git/DRAFT/data/'
websky_folder = '/Volumes/data_PHD_WD_babbloo/SPTpol/data/websky/'
mdpl2_folder = '/Volumes/data_PHD_WD_babbloo/SPTpol/data/mdpl2/v0.3/'

if not os.path.exists(data_folder):
    data_folder = '/data48/sri/git/DRAFT/data/'
    websky_folder = '/data19/sri/websky/'
    mdpl2_folder = '/data48/sri/mdpl2/v0.3/'
if not os.path.exists(data_folder):
    data_folder = '/u/home/s/srinirag/project-nwhiteho/git/DRAFT/data/'
    websky_folder = '/u/home/s/srinirag/project-nwhiteho/websky/'
    mdpl2_folder = '/u/home/s/srinirag/project-nwhiteho/mdpl2/v0.3/'
if not os.path.exists(data_folder):
    data_folder = '/home/sri/analysis/git/DRAFT/data/'
    websky_folder = '/sptlocal/user/sri/websky/'
    mdpl2_folder = '/sptlocal/user/sri/mdpl2/v0.3/'
################################################################################################################

def get_foreground_power_spt(component, freq1=150, freq2=None, units='uk', lmax = None):
    """
    Foreground powers from George et al. 2015 results.

    Uses .sav file generated by Christain Reichardt.

    Parameters
    ----------
    component : str
        The foreground component to use. Must be one of
        'all', 'tSZ', 'kSZ', 'DG-Cl', 'DG-Po', 'RG', 'tSZ-CIB', 'Total', 'CMB'
    freq1 : int
        Frequency band. If `freq2` is specified, the cross-spectrum between
        the two frequencies will be returned. Otherwise autospectrum of freq1.
    freq2 : int, optional
        Frequency band for cross-spectrum with `freq1`
    units : str
        'k' or 'uk'. Note: default savfile is Dls in uK

    Returns
    -------
    fgnd_cls : array
        Power spectrum of `component` at specified frequency band.
    """
    components = [
        'all',
        'tSZ',
        'kSZ',
        'DG-Cl',
        'DG-Po',
        'RG',
        'tSZ-CIB',
        'Total',
        'CMB',
    ]
    if component not in components:
        raise ValueError(
            '{} not in list of possible foregrounds, must be one of {}'.format(
                component, components
            )
        )

    #filename = os.path.join(
    #    os.path.dirname(__file__), 'data/foregrounds/george_plot_bestfit_line.sav'
    #)

    #fix me: file / folder path
    from scipy.io import readsav
    try:
        filename = 'george_plot_bestfit_line.sav'
        data = readsav(filename)
    except:
        filename = '%s/george_plot_bestfit_line.sav' %(data_folder)
        data = readsav(filename)


    #from IPython import embed; embed()
    if freq2 is None:
        freq2 = freq1
    if freq1 == 90:
        freq1 = 95
    if freq2 == 90:
        freq2 = 95

    freqs = np.asarray(
        [(95, 95), (95, 150), (95, 220), (150, 150), (150, 220), (220, 220)]
    )
    dl_all = data['ml_dls'][(freqs[:, 0] == freq1) & (freqs[:, 1] == freq2)][0]
    labels = data['ml_dl_labels'].astype('str')
    el = np.asarray(data['ml_l'], dtype=int)

    if component == 'all':
        spec = el * 0.0
        for fg in components:
            if fg in ['all', 'tSZ-CIB', 'Total', 'CMB']:
                continue
            spec += dl_all[labels == fg][0]
    else:
        spec = dl_all[labels == component][0]

    # Changing Dls to Cls
    spec /= el * (el + 1.0) / 2.0 / np.pi
    if units.lower() == 'k':
        spec /= 1e12

    # Pad to l=0
    spec = np.concatenate((np.zeros(min(el)), spec))
    el = np.concatenate((np.arange(min(el)), el))

    if lmax is not None:
        el = el[:lmax]
        spec = spec[:lmax]

    return el, spec

################################################################################################################

def get_cl_galactic(param_dict, component, freq1, freq2, which_spec, which_gal_mask = 0, bl_dic = None, el = None):

    gal_freq_dic = {20:20, 27:27, 39: 39, 93: 93, 90: 93, 143: 143, 145: 145, 150: 150, 225: 225, 220: 225, 278:278, }

    #https://healpy.readthedocs.io/en/1.5.0/generated/healpy.sphtfunc.anafast.html#healpy.sphtfunc.anafast
    spec_inds_dic = { 'TT':0, 'EE':1, 'BB':2, 'TE':3, 'EB':4, 'TB':5} #py2

    assert component in ['dust', 'sync']

    try:
        which_gal_mask = param_dict['which_gal_mask']
    except:
        pass

    if component == 'dust':
        cl_gal_dic_fname = param_dict['cl_gal_dic_dust_fname']
    elif component == 'sync':
        cl_gal_dic_fname = param_dict['cl_gal_dic_sync_fname']

    try:
        cl_gal_folder = param_dict['cl_gal_folder']
        cl_gal_dic_fname = '%s/%s' %(cl_gal_folder, cl_gal_dic_fname)
    except:
        pass

    if (0):##component == 'sync':
        #fix me: Forcing sync. to CUmilta's simulations
        print('\n\t\tForcing sync. to CUmilta\'s simulations\n\n')
        try:
            cl_gal_dic_fname = param_dict['cl_gal_dic_sync_fname_forced']
        except:
            pass

    cl_gal_dic = np.load(cl_gal_dic_fname, allow_pickle = 1, encoding = 'latin1').item()['cl_dic'][which_gal_mask]
    freq1_to_use = gal_freq_dic[freq1]
    freq2_to_use = gal_freq_dic[freq2]
    try:
        cl_gal = cl_gal_dic[ (freq1_to_use, freq2_to_use) ]
    except:
        cl_gal = cl_gal_dic[ (freq2_to_use, freq1_to_use) ]

    #pick the requested spectra: TT, EE, BB, TE, EB, TB.
    spec_ind = spec_inds_dic[which_spec]

    #fix me
    if np.ndim(cl_gal) == 1: #TT-only. Pol will fail.
        cl_gal = np.asarray( [cl_gal] )

    if which_spec == 'TE' and cl_gal_dic_fname.find('CUmilta')==-1:
        #force TE to be np.sqrt(TT) * np.sqrt(EE)
        ###cl_gal = np.sqrt( cl_gal[0] * cl_gal[1] )
        cl_gal_tt, cl_gal_ee = cl_gal_dic[ (freq1, freq2) ][0], cl_gal_dic[ (freq1, freq2) ][1]

        if (1):##component == 'dust':
            rte = 0.35 #page 5 of https://arxiv.org/pdf/1801.04945.pdf: Discussion below Fig.5; also page 38 of https://readthedocs.org/projects/so-pysm-models/downloads/pdf/0.2.dev/
        else: ##elif component == 'sync':
            rte = 0.
        cl_gal = rte * np.sqrt( cl_gal_tt * cl_gal_ee )

    else:
        try:
            cl_gal = cl_gal[spec_ind]
        except:
            print('(%s,%s) not found for mask = %s in %s. Setting them to zeros.' %(freq1, freq2, which_spec, cl_gal_dic_fname))
            cl_gal = np.zeros( len(cl_gal[0]) )

    el_gal = np.arange( len(cl_gal) )

    if bl_dic is not None:
        bl1 = bl_dic[freq1]
        bl2 = bl_dic[freq2]

        if len(bl1) != len(cl_gal): #adjust array lengths first
            el_tmp = np.arange( len(bl1) )
            cl_gal = np.interp(el_tmp, el_gal, cl_gal, left = 0., right = 0.)
            el_gal = np.copy( el_tmp )

        cl_gal = cl_gal / (bl1 * bl2)

        if (0): #20210426 - nulling highly smoothed modes
            op_beam = bl_dic[145]
            beam_ratio = op_beam**2. / (bl1 * bl2)
            highly_deconv_inds = np.where(beam_ratio>=500)
            cl_gal[highly_deconv_inds] = 0.
            #plot(beam_ratio); ylim(1., 1000.); show(); sys.exit()

    if el is not None:
        cl_gal = np.interp(el, el_gal, cl_gal, left = 0., right = 0.)
        el_gal = np.copy( el )

    return el_gal, cl_gal

def get_cl_dust_galactic(el, freq1, freq2 = None, freq0 = 353., el_norm = 80., el_slope = -0.58, Tdust = 19.6, Adust_freq0 = 4.3, spec_index_dust = 1.6, return_dl = 0):

    if freq2 is None:
        freq2 = freq1

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    bnu1 = fn_BnuT(freq1, temp = Tdust)
    bnu2 = fn_BnuT(freq2, temp = Tdust)
    bnu0 = fn_BnuT(freq0, temp = Tdust)

    etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
    etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
    etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0

    dl_dust = Adust_freq0 * epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust) * (el*1./el_norm)**el_slope

    if return_dl:
        return dl_dust
    else:
        dl_fac = el * (el+1)/2/np.pi
        cl_dust = dl_dust / dl_fac
    return cl_dust


