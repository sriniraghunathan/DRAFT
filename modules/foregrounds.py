import numpy as np, sys, os, scipy as sc
from scipy import interpolate as intrp
from scipy import ndimage
from pylab import *

h, k_B, c=6.626e-34,1.38e-23, 3e8
data_folder = '/Users/sraghunathan/Research/SPTPol/analysis/git/DRAFT/data/'
websky_folder = '/Volumes/data_PHD_WD_babbloo/SPTpol/data/websky/'
mdpl2_folder = '/Volumes/data_PHD_WD_babbloo/SPTpol/data/mdpl2/v0.3/'

if not os.path.exists(data_folder):
    data_folder = '/data48/sri/git/DRAFT/data/'
    websky_folder = '/data19/sri/websky/'
    mdpl2_folder = '/data48/sri/mdpl2/v0.3/'
################################################################################################################

def get_foreground_power_spt(component, freq1=150, freq2=None, units='uk', lmax = None):
    """
    Foreground powers from George et al. 2015 results.

    Uses .sav file generated by Christain Reichardt.

    Parameters
    ----------
    component : str
        The foreground component to use. Must be one of
        'all', 'tSZ', 'kSZ', 'DG-Cl', 'DG-Po', 'RG', 'tSZ-CIB', 'Total', 'CMB'
    freq1 : int
        Frequency band. If `freq2` is specified, the cross-spectrum between
        the two frequencies will be returned. Otherwise autospectrum of freq1.
    freq2 : int, optional
        Frequency band for cross-spectrum with `freq1`
    units : str
        'k' or 'uk'. Note: default savfile is Dls in uK

    Returns
    -------
    fgnd_cls : array
        Power spectrum of `component` at specified frequency band.
    """
    components = [
        'all',
        'tSZ',
        'kSZ',
        'DG-Cl',
        'DG-Po',
        'RG',
        'tSZ-CIB',
        'Total',
        'CMB',
    ]
    if component not in components:
        raise ValueError(
            '{} not in list of possible foregrounds, must be one of {}'.format(
                component, components
            )
        )

    #filename = os.path.join(
    #    os.path.dirname(__file__), 'data/foregrounds/george_plot_bestfit_line.sav'
    #)

    #fix me: file / folder path
    from scipy.io import readsav
    try:
        filename = 'george_plot_bestfit_line.sav'
        data = readsav(filename)
    except:
        filename = '%s/george_plot_bestfit_line.sav' %(data_folder)
        data = readsav(filename)


    #from IPython import embed; embed()
    if freq2 is None:
        freq2 = freq1
    if freq1 == 90:
        freq1 = 95
    if freq2 == 90:
        freq2 = 95

    freqs = np.asarray(
        [(95, 95), (95, 150), (95, 220), (150, 150), (150, 220), (220, 220)]
    )
    dl_all = data['ml_dls'][(freqs[:, 0] == freq1) & (freqs[:, 1] == freq2)][0]
    labels = data['ml_dl_labels'].astype('str')
    el = np.asarray(data['ml_l'], dtype=int)

    if component == 'all':
        spec = el * 0.0
        for fg in components:
            if fg in ['all', 'tSZ-CIB', 'Total', 'CMB']:
                continue
            spec += dl_all[labels == fg][0]
    else:
        spec = dl_all[labels == component][0]

    # Changing Dls to Cls
    spec /= el * (el + 1.0) / 2.0 / np.pi
    if units.lower() == 'k':
        spec /= 1e12

    # Pad to l=0
    spec = np.concatenate((np.zeros(min(el)), spec))
    el = np.concatenate((np.arange(min(el)), el))

    if lmax is not None:
        el = el[:lmax]
        spec = spec[:lmax]

    return el, spec

################################################################################################################

def fn_dB_dT(nu, nu0 = None, temp = 2.725):
    if nu<1e4: nu *= 1e9

    x=h*nu/(k_B*temp)
    dBdT = x**4. * np.exp(x) / (np.exp(x)-1)**2.

    if nu0 is not None:
        nu0 *= 1e9
        x0=h*nu0/(k_B*temp)
        dBdT0 = x0**4 * np.exp(x0) / (np.exp(x0)-1)**2.
        return  dBdT / dbdT0
    else:
        return dBdT

def fn_BnuT(nu, temp = 2.725):
    if nu<1e4: nu *= 1e9
    x=h*nu/(k_B*temp)

    t1 = 2 * h * nu**3./ c**2.
    t2 = 1./ (np.exp(x)-1.)

    return t1 * t2

def coth(x):
    return (np.exp(x) + np.exp(-x)) / (np.exp(x) - np.exp(-x))

def compton_y_to_delta_Tcmb(freq1, freq2 = None, Tcmb = 2.73):

    """ad
    c.f:  table 1, sec. 3 of arXiv: 1303.5081; 
    table 8 of http://arxiv.org/pdf/1303.5070.pdf
    no relativistic corrections included.
    freq1, freq2 = frequencies in GHz to cover the bandpass
    freq2 = None will force freq1 to be the centre frequency
    """

    if freq1<1e4: freq1 = freq1 * 1e9

    if not freq2 is None:
        if freq2<1e4: freq2 = freq2 * 1e9
        freq = np.arange(freq1,freq2,delta_nu)
    else:
        freq = np.asarray([freq1])

    x = (h * freq) / (k_B * Tcmb)
    g_nu = x * coth(x/2.) - 4.

    return Tcmb * np.mean(g_nu)

def get_cl_dust(freq1, freq2, fg_model = 'george15', freq0 = 150, spec_index_dg_po = 1.505 - 0.077, spec_index_dg_clus = 2.51-0.2, Tcib = 20.):
    if fg_model == 'george15':
        el, cl_dg_po_freq0 = get_foreground_power_spt('DG-Po', freq1 = freq0, freq2 = freq0)
        el, cl_dg_clus_freq0 = get_foreground_power_spt('DG-Cl', freq1 = freq0, freq2 = freq0)
        el_norm = 3000

    #conert to Dls
    dl_fac = el * (el+1)/2/np.pi
    dl_dg_po = dl_fac * cl_dg_po_freq0
    dl_dg_clus = dl_fac * cl_dg_clus_freq0

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    bnu1 = fn_BnuT(freq1, temp = Tcib)
    bnu2 = fn_BnuT(freq2, temp = Tcib)
    bnu0 = fn_BnuT(freq0, temp = Tcib)

    etanu1_dg_po = ((1.*freq1*1e9)**spec_index_dg_po) * bnu1
    etanu2_dg_po = ((1.*freq2*1e9)**spec_index_dg_po) * bnu2
    etanu0_dg_po = ((1.*freq0*1e9)**spec_index_dg_po) * bnu0

    etanu1_dg_clus = ((1.*freq1*1e9)**spec_index_dg_clus) * bnu1
    etanu2_dg_clus = ((1.*freq2*1e9)**spec_index_dg_clus) * bnu2
    etanu0_dg_clus = ((1.*freq0*1e9)**spec_index_dg_clus) * bnu0

    dl_dg_po = dl_dg_po[el == el_norm][0] * epsilon_nu1_nu2 * (1.*etanu1_dg_po * etanu2_dg_po/etanu0_dg_po/etanu0_dg_po) * (el*1./el_norm)**2
    dl_dg_clus = dl_dg_clus[el == el_norm][0] * epsilon_nu1_nu2 * (1.*etanu1_dg_clus * etanu2_dg_clus/etanu0_dg_clus/etanu0_dg_clus) * (el*1./el_norm)**0.8

    cl_dg_po = dl_dg_po / dl_fac
    cl_dg_clus = dl_dg_clus / dl_fac

    cl_dg_po[np.isnan(cl_dg_po)] = 0.
    cl_dg_clus[np.isinf(cl_dg_clus)] = 0.

    return el, cl_dg_po, cl_dg_clus

def get_cl_tsz(freq1, freq2, freq0 = 150, fg_model = 'george15'):

    if fg_model == 'george15':
        el, cl_tsz_freq0 = get_foreground_power_spt('tSZ', freq1 = freq0, freq2 = freq0)

    tsz_fac_freq0 = compton_y_to_delta_Tcmb(freq0*1e9)
    tsz_fac_freq1 = compton_y_to_delta_Tcmb(freq1*1e9)
    tsz_fac_freq2 = compton_y_to_delta_Tcmb(freq2*1e9)

    scalefac = tsz_fac_freq1 * tsz_fac_freq2/ (tsz_fac_freq0**2.)

    cl_tsz = cl_tsz_freq0 * scalefac
    cl_tsz[np.isnan(cl_tsz)] = 0.
    cl_tsz[np.isinf(cl_tsz)] = 0.

    return el, cl_tsz

def get_cl_tsz_cib(freq1, freq2, freq0 = 150, fg_model = 'george15', spec_index_dg_po = 1.505 - 0.077, spec_index_dg_clus = 2.51-0.2, Tcib = 20., use_websky_cib = 0, use_sptspire_for_hfbands = 0, use_mdpl2_cib = 0, cl_cib_dic = None):

    if fg_model == 'george15':
        corr_coeff = 0.1
    elif fg_mode == 'reichardt20':
        corr_coeff = 0.078

    el, cl_tsz_freq1_freq1 = get_cl_tsz(freq1, freq1, freq0 = freq0, fg_model = fg_model)
    if cl_cib_dic is not None:
        el, cl_dg_freq1_freq1 = cl_cib_dic[(freq1, freq1)]
    else:
        #get tSZ and CIB spectra for freq1
        el, cl_dg_po_freq1_freq1, cl_dg_clus_freq1_freq1 = get_cl_dust(freq1, freq1, freq0 = freq0, fg_model = fg_model, spec_index_dg_po = spec_index_dg_po, spec_index_dg_clus = spec_index_dg_clus, Tcib = Tcib)
        cl_dg_freq1_freq1 = cl_dg_po_freq1_freq1 + cl_dg_clus_freq1_freq1
        #20200804: replace CIB with websky/MDPL2/SPTxSPIRE as requested
        if use_websky_cib:
            el,  cl_dg_freq1_freq1 = get_cl_cib_websky(freq1, freq1, el = el)
        elif use_mdpl2_cib:
            #el,  cl_dg_freq1_freq1 = get_cl_cib_mdpl2(freq1, freq1, el = el)
            el,  cl_dg_freq1_freq1 = get_cl_cib_mdpl2_v0p3(freq1, freq1, el = el)
        elif use_sptspire_for_hfbands:
            if freq1>500:
                el, cl_dg_freq1_freq1 = get_spt_spire_bandpower(freq1, freq1, el_for_interp = el)    

    #get tSZ and CIB spectra for freq2
    el, cl_tsz_freq2_freq2 = get_cl_tsz(freq2, freq2, freq0 = freq0, fg_model = fg_model)
    if cl_cib_dic is not None:
        el, cl_dg_freq2_freq2 = cl_cib_dic[(freq2, freq2)]
    else:
        el, cl_dg_po_freq2_freq2, cl_dg_clus_freq2_freq2 = get_cl_dust(freq2, freq2, freq0 = freq0, fg_model = fg_model, spec_index_dg_po = spec_index_dg_po, spec_index_dg_clus = spec_index_dg_clus, Tcib = Tcib)
        cl_dg_freq2_freq2 = cl_dg_po_freq2_freq2 + cl_dg_clus_freq2_freq2
        #20200804: replace CIB with websky/MDPL2/SPTxSPIRE as requested
        if use_websky_cib:
            el,  cl_dg_freq2_freq2 = get_cl_cib_websky(freq2, freq2, el = el)
        elif use_mdpl2_cib:
            #el,  cl_dg_freq2_freq2 = get_cl_cib_mdpl2(freq2, freq2, el = el)
            el,  cl_dg_freq2_freq2 = get_cl_cib_mdpl2_v0p3(freq2, freq2, el = el)
        elif use_sptspire_for_hfbands:
            if freq2>500:
                el, cl_dg_freq2_freq2 = get_spt_spire_bandpower(freq2, freq2, el_for_interp = el)    

    cl_tsz_cib = corr_coeff * ( np.sqrt(cl_tsz_freq1_freq1 * cl_dg_freq2_freq2) + np.sqrt(cl_tsz_freq2_freq2 * cl_dg_freq1_freq1) )

    return el, cl_tsz_cib

def get_cl_radio(freq1, freq2, freq0 = 150, fg_model = 'george15', spec_index_rg = -0.9, null_highfreq_radio = 1, reduce_radio_power_150 = None):

    if fg_model == 'george15':
        el, cl_rg_freq0 = get_foreground_power_spt('RG', freq1 = freq0, freq2 = freq0)
        if reduce_radio_power_150 is not None:
            cl_rg_freq0 /= reduce_radio_power_150
        el_norm = 3000

    #conert to Dls
    dl_fac = el * (el+1)/2/np.pi
    dl_rg = dl_fac * cl_rg_freq0

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    dl_rg = dl_rg[el == el_norm][0] * epsilon_nu1_nu2 * (1.*freq1 * freq2/freq0/freq0)**spec_index_rg * (el*1./el_norm)**2

    cl_rg = dl_rg / dl_fac

    cl_rg[np.isnan(cl_rg)] = 0.

    if null_highfreq_radio and (freq1>230 or freq2>230):
        #print('\n\tthis extrapolation does not work for high freqeuncy radio. Making cl_radio = 0 for these bands.')
        cl_rg *= 0.

    return el, cl_rg


############################################################
############################################################
#all websky stuff
def websky_cib_unit_conversion(freq, freq0 = 100e9):

    x = freq/56.8e9
    t_cmb = 2.7255 #kelvin
    t1 = 1.05e3
    t2 = (np.exp(x) - 1.)**2.
    t3 = np.exp(-x)
    t4 = (freq / freq0)**-4

    return t1 * t2 * t3 * t4

def get_point_source_mask_in_healpix_cib(freq, hmap_Mjy_per_sr, threshold_mjy_freq0, freq0 = 150., spec_index_dg = 3.4):
    import healpy as H

    nside = H.get_nside(hmap_Mjy_per_sr)
    pix_area = H.nside2resol(nside)**2.
    hmap_Mjy = np.copy( hmap_Mjy_per_sr ) * pix_area
    MJy_mJy = 1e9
    hmap_mjy = hmap_Mjy * MJy_mJy

    scaling = (freq / freq0) ** spec_index_dg
    threshold_mjy = threshold_mjy_freq0 * scaling

    mask_pixels = np.where(hmap_mjy >= threshold_mjy)[0]

    return mask_pixels

def mask_point_sources_in_healpix_cib(freq, hmap, hmap_Mjy_per_sr = None, threshold_mjy_freq0 = None, mask_fname = '%s/spt_like_mask_6.4mJy_143GHz.fits' %(websky_folder)):
    import healpy as H

    nside = H.get_nside(hmap)
    if hmap_Mjy_per_sr is None:
        mask = H.read_map( mask_fname, verbose = 0 )
        nside_mask = H.get_nside(mask)
        assert nside == nside_mask
        mask_pixels = np.where(mask == 0.)[0]
    else:
        mask_pixels = get_point_source_mask_in_healpix_cib(freq, hmap_Mjy_per_sr, threshold_mjy_freq0)

    nearest_neighbours = H.get_all_neighbours(nside, mask_pixels)#mask_theta, mask_phi)
    mean_values = np.mean(hmap[nearest_neighbours[:,None]], axis = 0)
    hmap[mask_pixels] = mean_values

    return hmap

def get_websky_healpix(freq, use_mask = 1, websky_scaling_map = 0.75, threshold_mjy_freq0 = 1.5):
    import healpy as H
    websky_freq_dic = {90: 93, 93: 93, 95: 93, 143: 145, 145: 145, 150: 145, 217: 217, 220: 217, 225: 225, 286: 278, 345: 353, 545: 545, 600: 545, 857: 857}
    mapname = '%s/cib_nu%04d.fits' %(websky_folder, websky_freq_dic[freq])
    conv_factor = websky_cib_unit_conversion(freq * 1e9)
    hmap_raw = H.read_map(mapname)#, verbose = 0)
    hmap = np.copy(hmap_raw) * conv_factor * websky_scaling_map
    #hmap = mask_point_sources_in_healpix_cib(hmap)
    hmap = mask_point_sources_in_healpix_cib(freq, hmap, hmap_Mjy_per_sr = hmap_raw, threshold_mjy_freq0 = threshold_mjy_freq0)

    return hmap

def get_cl_cib_websky(freq1, freq2, units = 'uk', websky_scaling_power = 0.75**2., el = None):
#def get_cl_cib_websky(freq1, freq2, units = 'uk', websky_scaling_power = 1., el = None):
    websky_freq_dic = {90: 93, 93: 93, 95: 93, 143: 145, 145: 145, 150: 145, 217: 217, 220: 217, 225: 225, 286: 278, 345: 353, 545: 545, 600: 545, 857: 857}
    fname = '%s/websky/cl_websky_cib_masked.npy' %(data_folder)
    websky_freq1 = websky_freq_dic[freq1]
    websky_freq2 = websky_freq_dic[freq2]
    cl_cib_dic = np.load(fname, allow_pickle = 1, encoding = 'latin1').item()['cl_dic']
    freq_key = (websky_freq1, websky_freq2)
    if freq_key not in cl_cib_dic:
        freq_key = (websky_freq2, websky_freq1)
    cl_cib = cl_cib_dic[freq_key]
    if units.lower() == 'k':
        cl_cib /= 1e12
    cl_cib *= websky_scaling_power

    el_cib = np.arange( len(cl_cib) )
    if el is not None:
        cl_cib = np.interp(el, el_cib, cl_cib, left = 0., right = 0.)
        el_cib = np.copy( el )

    return el_cib, cl_cib

############################################################
############################################################
#all mdpl2 stuff
mdpl2_freq_dic_for_spt = {90: 90, 95: 90, 150: 150, 220: 220, 221: 221, 286: 286, 345: 345, 545: 545, 600: 545, 857: 857}
mdpl2_freq_dic_for_planck = {90: 100, 95: 100, 150: 143, 220: 217, 545: 545, 600: 545, 857: 857}

#Mjy/Sr -> K
mdpl2_flux_conv_planck = {100: 243.623, 143: 371.036, 217: 481.882, 353: 287.281, 545: 57.6963, 857: 2.26476}
mdpl2_flux_conv_spt = {90: 208.973, 150: 375.876, 220: 472.522, 221: 473.332, 286: 414.977, 345: 310.827}
mdpl2_flux_conv_herschel = {600: None, 857: 2.26476, 1200: None}

#colour corrections
mdpl2_col_corr_planck = {100: 1.1102, 143: 1.0324, 217: 1.1442, 353: 1.1398, 545: 1.1420, 857: 1.0439}
mdpl2_col_corr_spt = {90: 0.9708, 150: 0.9442, 220: 1.0239, 221: 1.0284, 286: 1.0234, 345: 1.0047}
mdpl2_col_corr_herschel = {600: 1.1339, 857: 1.0955, 1200: 1.0815}

#Planck to spt/herschle scalings
mdpl2_planck_to_spt_herschel_scaling_power = {(143, 150): 0.423, (217, 220): 1.64, (545, 600): 1.32, (857, 857): 0.98}

def get_mdpl2_healpix(freq, which_set = 'spt', use_mask = 1, threshold_mjy_freq0 = 1.5):
    import healpy as H
    if which_set == 'spt':
        mdpl2_freq_dic = mdpl2_freq_dic_for_spt
    elif which_set == 'planck':
        mdpl2_freq_dic = mdpl2_freq_dic_for_planck

    mdpl2_freq = mdpl2_freq_dic[freq]
    if mdpl2_freq in mdpl2_flux_conv_planck:
        mapname = '%s/cibmap_sum_%d_planck.fits' %(mdpl2_folder, mdpl2_freq)
        conv_factor = mdpl2_flux_conv_planck[mdpl2_freq]
        col_corr = mdpl2_col_corr_planck[mdpl2_freq]
    elif mdpl2_freq in mdpl2_flux_conv_spt:
        mapname = '%s/cibmap_sum_%d.fits' %(mdpl2_folder, mdpl2_freq)
        conv_factor = mdpl2_flux_conv_spt[mdpl2_freq]
        col_corr = mdpl2_col_corr_spt[mdpl2_freq]

    hmap_raw = H.read_map(mapname)#, verbose = 0)
    hmap_raw /= 1e6 #go from Jy to MJy
    hmap_raw *= col_corr


    scaling_value_power = 1.
    if (mdpl2_freq, freq) in mdpl2_planck_to_spt_herschel_scaling_power:
        scaling_value_power = mdpl2_planck_to_spt_herschel_scaling_power[(mdpl2_freq, freq)]

    scaling_value_map = scaling_value_power ** 0.5
    print(scaling_value_map)

    hmap = np.copy(hmap_raw) * scaling_value_map /  conv_factor
    hmap = mask_point_sources_in_healpix_cib(freq, hmap, hmap_Mjy_per_sr = hmap_raw, threshold_mjy_freq0 = threshold_mjy_freq0)

    hmap = hmap * 1e6 #K to uK

    return hmap

def get_cl_cib_mdpl2_v0p3(freq1, freq2, units = 'uk', el = None, flux_threshold = 1.5):
    mdpl2_freq_dic = {90: 90, 93: 90, 95: 90, 143: 150, 145: 150, 150: 150, 217: 220, 220: 220, 225: 221, 286: 286, 345: 345, 353: 345, 545: 600, 600: 600, 857: 857}
    fname = '%s/cl_cib_%smJymasked.npy' %(mdpl2_folder, flux_threshold)
    mdpl2_freq1 = mdpl2_freq_dic[freq1]
    mdpl2_freq2 = mdpl2_freq_dic[freq2]
    cl_cib_dic = np.load(fname, allow_pickle = 1, encoding = 'latin1').item()['cl_dic']    
    freq_key = (mdpl2_freq1, mdpl2_freq2)
    if freq_key not in cl_cib_dic:
        freq_key = (mdpl2_freq2, mdpl2_freq1)
    cl_cib = cl_cib_dic[freq_key]
    if units.lower() == 'k':
        cl_cib /= 1e12

    el_cib = np.arange( len(cl_cib) )
    if el is not None:
        cl_cib = np.interp(el, el_cib, cl_cib, left = 0., right = 0.)
        el_cib = np.copy( el )

    if freq1 == freq2 and freq1 != mdpl2_freq1:
        scale_fac_power = 1.
        if (freq1, mdpl2_freq1) in mdpl2_planck_to_spt_herschel_scaling_power:
            scale_fac_power = 1./mdpl2_planck_to_spt_herschel_scaling_power[(freq1, mdpl2_freq1)]
        elif (mdpl2_freq1, freq1) in mdpl2_planck_to_spt_herschel_scaling_power:
            scale_fac_power = mdpl2_planck_to_spt_herschel_scaling_power[(freq1, mdpl2_freq1)]
        cl_cib = cl_cib / scale_fac_power

    return el_cib, cl_cib

def get_cl_cib_mdpl2(freq1, freq2, units = 'uk', el = None, extend_to_higher_els = 1):

    #conversion factors: Kcmb-to-Mjy/Sr for maps
    #mdpl2_spt_conv = {90: 221.832, 150: 394.862, 220: 468.451}
    mdpl2_freq_dic = {90: 90, 93: 90, 95: 90, 143: 150, 145: 150, 150: 150, 217: 220, 220: 220, 225: 220, 545: 545, 600: 545, 857: 857}
    mdpl2_freq1 = mdpl2_freq_dic[freq1]
    mdpl2_freq2 = mdpl2_freq_dic[freq2]
    mdpl2_conv = {90: 248.173, 150: 426.433, 220: 529.49, 545: 57.6963, 857: 2.26476}

    exp_freq_dic = {90: 'spt', 150: 'spt', 220: 'spt', 100: 'planck', 143: 'planck', 217: 'planck', 353: 'planck', 545: 'planck', 600: 'planck', 857: 'planck'}
    fd = '%s/mdpl2_CIB/' %(data_folder)
    fname = '%s/cls_mdpl2_%s%03d_%s%03d_lensed.dat' %(fd, exp_freq_dic[freq1], mdpl2_freq1, exp_freq_dic[freq2], mdpl2_freq2)
    if not os.path.exists( fname ):
        fname = '%s/cls_mdpl2_%s%03d_%s%03d_lensed.dat' %(fd, exp_freq_dic[freq2], mdpl2_freq2, exp_freq_dic[freq1], mdpl2_freq1)

    cl_cib = np.loadtxt(fname)#/(2.73**2.)
    #cl_cib = cl_cib[:4096]
    if units.lower() == 'k':
        cl_cib /= 1e12

    conv1  = 1./mdpl2_conv[mdpl2_freq1]
    conv2 = 1./mdpl2_conv[mdpl2_freq2]
    conv = np.sqrt(conv1 * conv2)**2.
    cl_cib *= conv

    el_cib = np.arange( len(cl_cib) )

    if extend_to_higher_els: #extend the Poisson power with random values centered on Poisson mean and using Poisson std. dev.
        max_el = 12000
        el_cib_tmp = np.arange(max_el)
        pad_len = len(el_cib_tmp) - len(el_cib)
        if pad_len>1:
            el_poi = 3500
            poi_inds = np.where(el_cib>=el_poi)[0]
            cl_poi_mean_val, cl_poi_std_val = np.median(cl_cib[poi_inds]), np.std(cl_cib[poi_inds])
            cl_cib_tmp_ext_vals = np.random.standard_normal(pad_len) * cl_poi_std_val/10. + cl_poi_mean_val
            cl_cib_tmp = np.concatenate( (cl_cib, cl_cib_tmp_ext_vals) )
            #clf();loglog(el_cib, cl_cib); loglog(el_cib_tmp, cl_cib_tmp, lw = 0.2); show()

            el_cib = np.copy(el_cib_tmp )
            cl_cib = np.copy( cl_cib_tmp )

    if el is not None:
        cl_cib = np.interp(el, el_cib, cl_cib, left = 0., right = 0.)
        el_cib = np.copy( el )

    if (0):
        cl_cib = smooth_cib_spectra(el_cib, cl_cib)

    return el_cib, cl_cib

def smooth_cib_spectra(el, cl, min_el = 200):
    el_ori = np.copy(el)
    non_zero_ind = np.where(el>min_el)[0]
    el = el[non_zero_ind]
    cl = cl[non_zero_ind]

    el = el.astype(np.float64)
    def fitting_func_dust(p, x, DATA = None, return_fit = 0, el_slope = 1.2):
        fitfunc = lambda p, x: p[0]*( 1 + (p[1]/x)**p[2])
        #fitfunc = lambda p, x: p[0]*( 1 + (p[1]/x)**el_slope)
        if not return_fit:
            val = fitfunc(p, x) - DATA
            val[np.isinf(val)] = 0.
            val[np.isnan(val)] = 0.
            return val
        else:
            return fitfunc(p, x)

    def fitfunc(x, p1, p2, p3):        
        return p1*( 1. + (p2/x)**p3)

    import scipy.optimize as optimize
    el_knee_guess = 2000
    #low_ell_cls = np.median(curr_cls[curr_els<ell_for_splitting])
    #high_ell_cls = np.median(curr_cls[curr_els>ell_for_splitting])
    poi_level = np.median(cl[el>el_knee_guess])
    el_slope = 1.2 #0.8 for Dl and 1.2 for Cl
    p0 = np.asarray( [poi_level, el_knee_guess, el_slope] )
    p1, cov, infodict, success, msg = optimize.leastsq(fitting_func_dust, p0, args=(el, cl), full_output = 1)
    if p1[1]<0:
        p1 = p0
    #p1, pcov = optimize.curve_fit(fitfunc, el, cl, p0=p0)
    #print(p0, p1);sys.exit()
    cl_fit = fitting_func_dust(p1, el, return_fit = 1)

    #from IPython import embed; embed()
    #cl_fit = ndimage.filters.gaussian_filter1d(cl, sigma = 10) 

    #clf(); semilogy(cl); semilogy(cl_fit); show(); sys.exit()

    cl_fit = np.interp(el_ori, el, cl_fit, left = 0., right = 0.)

    return cl_fit

#def get_spt_spire_bandpower(freq1 = None, freq2 = None, fd = 'data/spt_spire/', units = 'tcmb', el_for_interp = None, use_corr_coeff = 0, comps_to_subtract = None, param_dict = None):
def get_spt_spire_bandpower(freq1 = None, freq2 = None, fd = None, units = 'tcmb', el_for_interp = None, use_corr_coeff = 0, comps_to_subtract = None, param_dict = None):

    if (1):
        cib_corr_coeffs= {}
        cib_corr_coeffs[(90, 150)] = 0.53
        cib_corr_coeffs[(90, 220)] = 0.68
        cib_corr_coeffs[(90, 600)] = 0.46
        cib_corr_coeffs[(90, 857)] = 0.40
        cib_corr_coeffs[(90, 1200)] = 0.36

        cib_corr_coeffs[(150, 220)] = 0.976
        cib_corr_coeffs[(150, 600)] = 0.879
        cib_corr_coeffs[(150, 857)] = 0.789
        cib_corr_coeffs[(150, 1200)] = 0.650

        cib_corr_coeffs[(220, 600)] = 0.879
        cib_corr_coeffs[(220, 857)] = 0.786
        cib_corr_coeffs[(220, 1200)] = 0.643

        cib_corr_coeffs[(600, 857)] = 0.970
        cib_corr_coeffs[(600, 1200)] = 0.861

        cib_corr_coeffs[(857, 1200)] = 0.9551

    if fd is None:
        fd = '%s/spt_spire/' %(data_folder)
    spec_fname = '%s/spectrum_sptxspire.txt' %(fd)

    ell_spt_spt = [2068, 2323, 2630, 2932, 3288, 3690, 4143, 4645, 5198, 5851, 6604, 7406, 8309, 9312, 10416]
    ell_spt_spire = [900, 1100, 1300, 1500, 1700, 1900, 2100, 2350, 2650, 2950, 3300, 3700, 4150, 4650, 5200, 5849, 6599, 7399, 8299, 9299, 10399]
    ell_spt_90_spire = [2100, 2350, 2650, 2950, 3300, 3700, 4150, 4650, 5200, 5849, 6599, 7399, 8299, 9299]
    ell_spt_150_spire = [1100, 1300, 1500, 1700, 1900, 2100, 2350, 2650, 2950, 3300, 3700, 4150, 4650, 5200, 5849, 6599, 7399, 8299, 9299, 10399]
    ell_spire = [700, 900, 1100, 1300, 1500, 1700, 1900, 2100, 2350, 2650, 2950, 3300, 3700, 4150, 4650, 5200, 5849, 6599, 7399, 8299, 9299, 10399]

    ell_spt_spt = np.asarray( ell_spt_spt )
    ell_spire = np.asarray( ell_spire )
    ell_spt_spire = np.asarray( ell_spt_spire )
    ell_spt_90_spire = np.asarray( ell_spt_90_spire )
    ell_spt_150_spire = np.asarray( ell_spt_150_spire )

    spt_freq_arr = np.asarray( [90, 150, 220] )
    spire_freq_arr = np.asarray( [600, 857, 1200] )
    spt_spire_freq_arr = np.asarray( [90, 150, 220, 600, 857, 1200] ) #GHz
    spt_spire_freq_crosses = []
    for f1 in spt_spire_freq_arr:
        for f2 in spt_spire_freq_arr:
            if (f2, f1) in spt_spire_freq_crosses: continue
            spt_spire_freq_crosses.append( (f1, f2) )

    tot_spec_combs = len( spt_spire_freq_crosses )

    binno, sptspirecl = np.loadtxt( spec_fname, unpack = 1 )
    break_inds = np.where(binno == 0)[0]
    assert len(break_inds) == tot_spec_combs

    units_scale_conv_factor_file = '%s/info.txt' %(fd)
    scale_factor_arr, units_flag_arr = np.loadtxt(units_scale_conv_factor_file, skiprows = tot_spec_combs, unpack = 1, max_rows = tot_spec_combs)
    #we will not use the scale_factor here.
    conv_factor_arr = np.loadtxt(units_scale_conv_factor_file, skiprows = tot_spec_combs*2)

    show_plot = 0
    if show_plot: clf(); ax = subplot(111, yscale = 'log')

    #now assign binned spectra to spt_spire_freq_crosses
    spt_spire_freq_crosses_dic = {}
    for cntr, (f1, f2) in enumerate( spt_spire_freq_crosses ):
        if cntr+1 < len(break_inds):
            inds_for_this_freq_comb = np.arange(break_inds[cntr], break_inds[cntr+1])
        else:
            inds_for_this_freq_comb = np.arange(break_inds[cntr], break_inds[cntr] + 22)

        curr_binno, curr_cls = binno[inds_for_this_freq_comb], sptspirecl[inds_for_this_freq_comb]
        curr_binno = curr_binno.astype(int)

        #apply scale factor
        scale_factor = scale_factor_arr[cntr]
        curr_cls /= scale_factor

        if f1 in spt_freq_arr and f2 in spt_freq_arr:
            curr_els = ell_spt_spt[curr_binno]
        elif f1 in spire_freq_arr and f2 in spire_freq_arr:
            curr_els = ell_spire[curr_binno]
        else:
            curr_els = ell_spt_spire[curr_binno]
            if f1 == 90 or f2 == 90:
                curr_els = ell_spt_90_spire
            elif f1 == 150 or f2 == 150:
                curr_els = ell_spt_150_spire

        dl_fac = curr_els*(curr_els+1)/2./np.pi


        #check units based on unit_flag
        f1_ind = np.where( spt_spire_freq_arr == f1)[0]
        f2_ind = np.where( spt_spire_freq_arr == f2)[0]
        #print(f1, f2, f1_ind, f2_ind)
        #[MJy^2/sr] to [uk_CMB^2]
        conv_factor_f1 = 1./(conv_factor_arr[f1_ind])
        conv_factor_f2 = 1./(conv_factor_arr[f2_ind])
        curr_conv_factor = np.sqrt( conv_factor_f1 * conv_factor_f2 )

        if (0):#f1 == 857 and f2 == 857:
            elind = 10
            print(spt_spire_freq_arr, f1_ind, f2_ind)
            print(curr_cls[elind]/1e3)
            print(curr_cls[elind])
            print(units)
            print(curr_cls[elind]*(curr_conv_factor**2.))

        if units_flag_arr[cntr] == 0:

            #print(f1, f2, conv_factor_f1, conv_factor_f2, curr_conv_factor)
            #curr_cls *= (curr_conv_factor)
            if units == 'tcmb':
                curr_cls *= (curr_conv_factor**2)

        elif units_flag_arr[cntr] == 1:
            curr_cls /= dl_fac
            if units == 'flux':
                curr_cls /= (curr_conv_factor**2)

        #perform interpolation, if requested
        if el_for_interp is not None:
            '''
            if (0): #smooth with polynomial fitting
                poly_deg = 1
                poly_fit_eq=np.polyfit(curr_els, curr_cls, poly_deg)
                poly_fit=np.poly1d(poly_fit_eq)
                curr_cls = poly_fit(curr_els)

                if (0):#f1>500 or f2>500:
                    clf()
                    plot(curr_els, curr_cls)
                    plot(curr_els, curr_cls_smoothed)
                    show(); sys.exit()
            '''
            curr_els_ori = np.copy(curr_els)
            if (0): #extrapolating to lower \ell as well
                fn_curr_cls_ip = intrp.interp1d(curr_els, curr_cls, fill_value = 'extrapolate')
                curr_cls_ip = fn_curr_cls_ip(el_for_interp)
            else:
                curr_cls_ip = np.interp(el_for_interp, curr_els, curr_cls, left = 0., right = curr_cls[-1])

            '''
            if (0): #smooth with polynomial fitting
                poly_deg = 1
                poly_fit_eq=np.polyfit(el_for_interp, curr_cls_ip, poly_deg)
                poly_fit=np.poly1d(poly_fit_eq)
                curr_cls_ip = poly_fit(curr_cls_ip)

            if (0): #smooth the curves a bit
                clf();loglog(curr_cls_ip)
                curr_cls_ip = ndimage.gaussian_filter1d(curr_cls_ip, sigma = 10.)
                loglog(curr_cls_ip)
                show()
                sys.exit()            
            '''

            el_norm = min(curr_els)
            curr_els = np.copy(el_for_interp)
            curr_cls = np.copy(curr_cls_ip)
            curr_cls[np.isinf(curr_cls)] = 0.
            curr_cls[np.isnan(curr_cls)] = 0.

            if comps_to_subtract is not None:
                for comp in comps_to_subtract:
                    if comp.lower() == 'cmb':
                        el, curr_cl_to_subtract = get_foreground_power_spt('CMB', freq1 = param_dict['freq0'], freq2 = param_dict['freq0'])
                    elif comp.lower() == 'ksz':
                        el, curr_cl_to_subtract = get_foreground_power_spt('kSZ', freq1 = param_dict['freq0'], freq2 = param_dict['freq0'])
                    elif comp.lower() == 'radio':
                        el, curr_cl_to_subtract = get_cl_radio(f1, f2, freq0 = param_dict['freq0'], fg_model = param_dict['fg_model'], spec_index_rg = param_dict['spec_index_rg'])#, reduce_radio_power_150 = param_dict['reduce_radio_power_150'])
                    elif comp.lower() == 'tsz':
                        el, curr_cl_to_subtract = get_cl_tsz(f1, f2, freq0 = param_dict['freq0'], fg_model = param_dict['fg_model'])
                    curr_cl_to_subtract = curr_cl_to_subtract[:len(el_for_interp)]
                    curr_cls = curr_cls - curr_cl_to_subtract

            if (1): # stitch it with a \ell^0.8 D_{\ell} or \ell^-1.2 C_{\ell}spectra
                ext_inds = np.where(curr_els<el_norm)[0]
                curr_cls[ext_inds] = curr_cls[curr_els == el_norm][0] * (1.*el_norm/curr_els[ext_inds])**1.2

                curr_cls[np.isinf(curr_cls)] = 0.
                curr_cls[np.isnan(curr_cls)] = 0.

            if (1): #fit white + 1/f for Poisson and clustering component                
                if (0):#f1 == 90 and f2 == 600:
                    print(curr_cls)
                    curr_cls_fit = smooth_cib_spectra(curr_els, curr_cls)
                    clf()
                    loglog(curr_cls)
                    loglog(curr_cls_fit)
                    title(r'%s,%s' %(f1, f2))
                    show()
                    sys.exit()

                curr_cls = smooth_cib_spectra(curr_els, curr_cls)

        if (0):#f1 == 857 and f2 == 857:
            elind = np.where(curr_els == 2950)[0]
            print(spt_spire_freq_arr, f1_ind, f2_ind)
            print(units)
            print(curr_cls[elind])
            sys.exit()

        if show_plot:
            #if f1 == f2 and f1>=600: 
            if f1>=600 and f2>=600 and (f1 == f2):
                print(f1, f2, curr_conv_factor)
                #print(curr_els, curr_cls)
                plot(curr_els, curr_cls, '.', label = r'%s,%s' %(f1, f2))
                if el_for_interp is not None:
                    plot(el_for_interp, curr_cls_ip, 'k-')
        spt_spire_freq_crosses_dic[(f1, f2)] = spt_spire_freq_crosses_dic[(f2, f1)] = [curr_els, curr_cls]

    if show_plot: 
        xlabel(r'Multipole $\ell$', fontsize = 14); 
        if units == 'tcmb':
            ylabel(r'C$_{\ell}$ [$\mu K^{2}$]', fontsize = 14)
        else:
            ylabel(r'C$_{\ell}$ [MJy$^{2}$/Sr]', fontsize = 14)
        legend(loc=3);
        #xlim(500, 11e4); ylim(1e3, 1e6); 
        title(r'SPIRE x SPIRE')
        show(); sys.exit()

    if use_corr_coeff:
        for tmpf1 in spt_spire_freq_arr:
            for tmpf2 in spt_spire_freq_arr:
                if tmpf1 == tmpf2: continue
                if (tmpf1,tmpf2) in cib_corr_coeffs:
                    curr_coff_coeff = cib_corr_coeffs[(tmpf1, tmpf2)]
                else:
                    curr_coff_coeff = cib_corr_coeffs[(tmpf2, tmpf1)]
                curr_auto_pspec_1 = spt_spire_freq_crosses_dic[(tmpf1,tmpf1)][1]
                curr_auto_pspec_2 = spt_spire_freq_crosses_dic[(tmpf2,tmpf2)][1]

                curr_cross_spec = np.sqrt( curr_auto_pspec_1 * curr_auto_pspec_2) * curr_coff_coeff
                curr_cross_spec[np.isinf(curr_cross_spec)]=0.
                curr_cross_spec = np.nan_to_num(curr_cross_spec)
                spt_spire_freq_crosses_dic[(tmpf1,tmpf2)][1] = np.copy( curr_cross_spec )

    #now select the required freq
    if freq1 is not None and freq2 is not None:
        if (0):#freq1 == 857 and freq2 == 857:
            elind = np.where(curr_els == 2950)[0]
            print(spt_spire_freq_crosses_dic[(freq1, freq2)][1][elind])
            #print(spt_spire_freq_crosses_dic[(freq1, freq2)][elind])
            sys.exit()

        return spt_spire_freq_crosses_dic[(freq1, freq2)]
    else:
        return spt_spire_freq_crosses_dic
    
def get_cl_galactic(param_dict, component, freq1, freq2, which_spec, which_gal_mask = 0, bl_dic = None, el = None):

    gal_freq_dic = {20:20, 27:27, 39: 39, 93: 93, 90: 93, 145: 145, 150: 145, 225: 225, 220: 225, 278:278, }

    #https://healpy.readthedocs.io/en/1.5.0/generated/healpy.sphtfunc.anafast.html#healpy.sphtfunc.anafast
    spec_inds_dic = { 'TT':0, 'EE':1, 'BB':2, 'TE':3, 'EB':4, 'TB':5} #py2

    assert component in ['dust', 'sync']

    try:
        which_gal_mask = param_dict['which_gal_mask']
    except:
        pass

    if component == 'dust':
        cl_gal_dic_fname = param_dict['cl_gal_dic_dust_fname']
    elif component == 'sync':
        cl_gal_dic_fname = param_dict['cl_gal_dic_sync_fname']

    try:
        cl_gal_folder = param_dict['cl_gal_folder']
        cl_gal_dic_fname = '%s/%s' %(cl_gal_folder, cl_gal_dic_fname)
    except:
        pass

    if (0):##component == 'sync':
        #fix me: Forcing sync. to CUmilta's simulations
        print('\n\t\tForcing sync. to CUmilta\'s simulations\n\n')
        try:
            cl_gal_dic_fname = param_dict['cl_gal_dic_sync_fname_forced']
        except:
            pass

    cl_gal_dic = np.load(cl_gal_dic_fname, allow_pickle = 1, encoding = 'latin1').item()['cl_dic'][which_gal_mask]
    freq1_to_use = gal_freq_dic[freq1]
    freq2_to_use = gal_freq_dic[freq2]
    try:
        cl_gal = cl_gal_dic[ (freq1_to_use, freq2_to_use) ]
    except:
        cl_gal = cl_gal_dic[ (freq2_to_use, freq1_to_use) ]

    #pick the requested spectra: TT, EE, BB, TE, EB, TB.
    spec_ind = spec_inds_dic[which_spec]

    #fix me
    if np.ndim(cl_gal) == 1: #TT-only. Pol will fail.
        cl_gal = np.asarray( [cl_gal] )

    ############################################################################################################
    ############################################################################################################
    ############################################################################################################
    #compare EE at \ell = 80 to table 1 of https://arxiv.org/pdf/1801.04945.pdf
    if (0):##which_spec == 'EE' and component == 'dust' and freq1 == 145 and freq1 == freq2: 
        freq0 = 353.
        el_norm = 80.
        Tdust = 20. ##19.6
        Adust_freq0 = 4.3
        spec_index_dust = 1.54 ##1.6
        nr = ( fn_dB_dT(freq0) )**2.
        dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

        epsilon_nu1_nu2 = nr/dr

        bnu1 = fn_BnuT(freq1, temp = Tdust)
        bnu2 = fn_BnuT(freq2, temp = Tdust)
        bnu0 = fn_BnuT(freq0, temp = Tdust)

        etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
        etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
        etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0    
        cl_ee = cl_gal_dic[ (freq1, freq2) ][1]
        mul_fac = epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust)
        print(mul_fac)
        print(component, freq1, freq2, cl_ee[80], cl_ee[80] / mul_fac)
        loglog(cl_ee); xlim(None, 200.); ylim(1e-6, 1e-2)
        sys.exit()
    ############################################################################################################
    ############################################################################################################
    ############################################################################################################

    if which_spec == 'TE' and cl_gal_dic_fname.find('CUmilta')==-1:
        #force TE to be np.sqrt(TT) * np.sqrt(EE)
        ###cl_gal = np.sqrt( cl_gal[0] * cl_gal[1] )
        cl_gal_tt, cl_gal_ee = cl_gal_dic[ (freq1, freq2) ][0], cl_gal_dic[ (freq1, freq2) ][1]

        if (1):##component == 'dust':
            rte = 0.35 #page 5 of https://arxiv.org/pdf/1801.04945.pdf: Discussion below Fig.5; also page 38 of https://readthedocs.org/projects/so-pysm-models/downloads/pdf/0.2.dev/
        else: ##elif component == 'sync':
            rte = 0.
        cl_gal = rte * np.sqrt( cl_gal_tt * cl_gal_ee )

        '''
        if (0):##component == 'sync':
            rho_dust_sync = 0.16 #Fig. 8 of https://arxiv.org/pdf/1801.04945.pdf
            cl_gal = cl_gal * rho_dust_sync

        if (0):#component == 'dust':   
            print('TE dust: scaling',)         
            ##cl_gal_old = np.copy(cl_gal)
            freq0 = 278
            rte = 0.35 
            cl_gal_tt, cl_gal_ee = cl_gal_dic[ (freq0, freq0) ][0], cl_gal_dic[ (freq0, freq0) ][1]
            cl_gal_freq0 = rte * np.sqrt( cl_gal_tt * cl_gal_ee )
            cl_gal = scale_cl_dust_galactic(cl_gal_freq0, freq1, freq2, freq0 = freq0)#, Tdust = 19.6, spec_index_dust = 1.6)

            if (0):
                color_dic = {93: 'b', 145: 'green', 225: 'orangered', 278: 'darkred'} 
                ls_dic = {93: ':', 145: '--', 225: '-.', 278: '-'} 
                loglog(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
                legend(loc = 3, fontsize = 8)
            if (0):
                loglog(cl_gal_old, 'k', ls = '-')
                loglog(cl_gal, color = 'orangered', ls ='--')
                title(r'%s: %s: %s,%s' %(component, which_spec, freq1, freq2))
                show()

            if (0):###freq1 != freq2:
                print('TE dust: nulling cross terms',)
                cl_gal *= 0.
        
        if (0):#component == 'sync':
            print('TE sync: nulling',)
            cl_gal *= 0.
        '''

        """
        else:
            '''
            if which_gal_mask == 3:
                ee_te_ratio = 5.
            else:
                ee_te_ratio = 2.7
            '''
            ee_te_ratio = 2.7
            spec_ind = 1 ##EE
            cl_gal = cl_gal_dic[ (freq1, freq2) ][spec_ind] * ee_te_ratio  
        loglog(cl_gal)
        loglog(cl_gal_dic[ (freq1, freq2) ][1] * 2.7)
        show();sys.exit()
        """
    else:
        try:
            cl_gal = cl_gal[spec_ind]
        except:
            print('(%s,%s) not found for mask = %s in %s. Setting them to zeros.' %(freq1, freq2, which_spec, cl_gal_dic_fname))
            cl_gal = np.zeros( len(cl_gal[0]) )

    if (0):##component == 'dust':
        color_dic = {93: 'b', 145: 'green', 225: 'orangered', 278: 'darkred'} 
        ls_dic = {93: ':', 145: '--', 225: '-.', 278: '-'}
        if which_spec == 'TT':
            ax = subplot(1,3,1, yscale = 'log')
            legend(loc = 3, fontsize = 4, ncol = 3)
            plot(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
            xlim(0., 7000.); ylim(1e-8, 1e7)
        elif which_spec == 'EE':
            ax = subplot(1,3,2, yscale = 'log')
            plot(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
            xlim(0., 7000.); ylim(1e-8, 1e7)
        elif which_spec == 'TE':
            ax = subplot(1,3,3, yscale = 'log')
            plot(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
            xlim(0., 7000.); ylim(1e-8, 1e7)

    el_gal = np.arange( len(cl_gal) )

    if bl_dic is not None:
        bl1 = bl_dic[freq1]
        bl2 = bl_dic[freq2]

        if len(bl1) != len(cl_gal): #adjust array lengths first
            el_tmp = np.arange( len(bl1) )
            cl_gal = np.interp(el_tmp, el_gal, cl_gal, left = 0., right = 0.)
            el_gal = np.copy( el_tmp )

        cl_gal = cl_gal / (bl1 * bl2)

    if el is not None:
        cl_gal = np.interp(el, el_gal, cl_gal, left = 0., right = 0.)
        el_gal = np.copy( el )

    return el_gal, cl_gal

def dB_dt_new(freq, tcmb = 2.725):

    h, k_B, c=6.626e-34,1.38e-23, 3e8

    x = (h/k_B)*(freq*1e9/tcmb)
    t1 = 2 * (h/c/tcmb)**2. * (1/k_B) * (freq*1e9)**4
    t2 = np.exp(x) / (np.exp(x) - 1)**2.

    dB_dt = t1 * t2 * 1e26

    return dB_dt

def lagache_scalings(cl, freq1, freq2, freq0):


    if freq1 == 90: freq1 = 95
    if freq2 == 90: freq2 = 95

    if freq1 == 600: freq1 = 545
    if freq2 == 600: freq2 = 545

    conv_MJyperSr_Kcmb_dic_spt_spire = {95: 234.042, 150: 413.540, 220: 477.017, 857: 2.124, 545: 42.275, 600: 41.275}

    sed_conv = {(95, 150): 0.2553, (95, 220): 0.08713, (150, 220): 0.3413, (857, 95): 294.03, (857, 150): 75.08, (857, 220): 25.62, (545, 95): 147.85, (545, 150): 37.75, (545, 220): 12.88}

    conv1 = conv_MJyperSr_Kcmb_dic_spt_spire[freq1]
    conv2 = conv_MJyperSr_Kcmb_dic_spt_spire[freq2]
    conv0 = conv_MJyperSr_Kcmb_dic_spt_spire[freq0]

    if (freq1, freq0) in sed_conv:
        sed_conv1 = sed_conv[(freq1, freq0)]
    elif (freq0, freq1) in sed_conv:
        sed_conv1 = 1./sed_conv[(freq0, freq1)]
    elif freq1 == freq0:
        sed_conv1 = 1.

    if (freq2, freq0) in sed_conv:
        sed_conv2 = sed_conv[(freq2, freq0)]
    elif (freq0, freq2) in sed_conv:
        sed_conv2 = 1./sed_conv[(freq0, freq2)]
    elif freq2 == freq0:
        sed_conv2 = 1.

    #print(freq1, freq2, freq0, conv1, conv2, conv0, sed_conv1, sed_conv2)
    #sys.exit()

    scaled_cl =  cl * (conv0/conv0/conv1*conv2) * ((sed_conv1*sed_conv2))

    return scaled_cl

def scale_cl_dust_galactic(cl, freq1, freq2 = None, freq0 = 278., Tdust = 19.6, spec_index_dust = 1.6):

    if freq2 is None:
        freq2 = freq1

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    if (0):
        t1 = dB_dt_new(freq0)
        t2 = dB_dt_new(freq1)
        nr = t1**2.
        dr = t2**2.
        epsilon_nu1_nu2 = nr/dr

        print(t1, t2, epsilon_nu1_nu2)

        sys.exit()

    bnu1 = fn_BnuT(freq1, temp = Tdust)
    bnu2 = fn_BnuT(freq2, temp = Tdust)
    bnu0 = fn_BnuT(freq0, temp = Tdust)

    etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
    etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
    etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0

    cl_dust = cl * epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust)## * (el*1./el_norm)**el_slope

    return cl_dust

def get_cl_dust_galactic(el, freq1, freq2 = None, freq0 = 353., el_norm = 80., el_slope = -0.58, Tdust = 19.6, Adust_freq0 = 4.3, spec_index_dust = 1.6, return_dl = 0):

    if freq2 is None:
        freq2 = freq1

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    bnu1 = fn_BnuT(freq1, temp = Tdust)
    bnu2 = fn_BnuT(freq2, temp = Tdust)
    bnu0 = fn_BnuT(freq0, temp = Tdust)

    etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
    etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
    etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0

    dl_dust = Adust_freq0 * epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust) * (el*1./el_norm)**el_slope

    if return_dl:
        return dl_dust
    else:
        dl_fac = el * (el+1)/2/np.pi
        cl_dust = dl_dust / dl_fac
    return cl_dust

"""
els = np.arange(1,100)
elval = 80.
Adust_90 = fn_dust_amp(elval, 90.)
Adust_150 = fn_dust_amp(elval, 150.)
Adust_220 = fn_dust_amp(elval, 220.)

#cl_dust_150 = fn_dust_amp(elval, 90.)

print(Adust_90, Adust_150, Adust_220)
"""

