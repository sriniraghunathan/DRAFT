import numpy as np, sys, os, scipy as sc
from pylab import *

h, k_B, c=6.626e-34,1.38e-23, 3e8
################################################################################################################

def get_foreground_power_spt(component, freq1=150, freq2=None, units='uk', lmax = None):
    """
    Foreground powers from George et al. 2015 results.

    Uses .sav file generated by Christain Reichardt.

    Parameters
    ----------
    component : str
        The foreground component to use. Must be one of
        'all', 'tSZ', 'kSZ', 'DG-Cl', 'DG-Po', 'RG', 'tSZ-CIB', 'Total', 'CMB'
    freq1 : int
        Frequency band. If `freq2` is specified, the cross-spectrum between
        the two frequencies will be returned. Otherwise autospectrum of freq1.
    freq2 : int, optional
        Frequency band for cross-spectrum with `freq1`
    units : str
        'k' or 'uk'. Note: default savfile is Dls in uK

    Returns
    -------
    fgnd_cls : array
        Power spectrum of `component` at specified frequency band.
    """
    components = [
        'all',
        'tSZ',
        'kSZ',
        'DG-Cl',
        'DG-Po',
        'RG',
        'tSZ-CIB',
        'Total',
        'CMB',
    ]
    if component not in components:
        raise ValueError(
            '{} not in list of possible foregrounds, must be one of {}'.format(
                component, components
            )
        )

    #filename = os.path.join(
    #    os.path.dirname(__file__), 'data/foregrounds/george_plot_bestfit_line.sav'
    #)

    #fix me: file / folder path
    from scipy.io import readsav
    try:
        filename = 'george_plot_bestfit_line.sav'
        data = readsav(filename)
    except:        
        filename = '/Users/sraghunathan/Research/SPTPol/analysis/git/DRAFT/data/george_plot_bestfit_line.sav'
        data = readsav(filename)


    #from IPython import embed; embed()
    if freq2 is None:
        freq2 = freq1
    if freq1 == 90:
        freq1 = 95
    if freq2 == 90:
        freq2 = 95

    freqs = np.asarray(
        [(95, 95), (95, 150), (95, 220), (150, 150), (150, 220), (220, 220)]
    )
    dl_all = data['ml_dls'][(freqs[:, 0] == freq1) & (freqs[:, 1] == freq2)][0]
    labels = data['ml_dl_labels'].astype('str')
    el = np.asarray(data['ml_l'], dtype=int)

    if component == 'all':
        spec = el * 0.0
        for fg in components:
            if fg in ['all', 'tSZ-CIB', 'Total', 'CMB']:
                continue
            spec += dl_all[labels == fg][0]
    else:
        spec = dl_all[labels == component][0]

    # Changing Dls to Cls
    spec /= el * (el + 1.0) / 2.0 / np.pi
    if units.lower() == 'k':
        spec /= 1e12

    # Pad to l=0
    spec = np.concatenate((np.zeros(min(el)), spec))
    el = np.concatenate((np.arange(min(el)), el))

    if lmax is not None:
        el = el[:lmax]
        spec = spec[:lmax]

    return el, spec

################################################################################################################

def fn_dB_dT(nu, nu0 = None, temp = 2.725):
    if nu<1e4: nu *= 1e9

    x=h*nu/(k_B*temp)
    dBdT = x**4. * np.exp(x) / (np.exp(x)-1)**2.

    if nu0 is not None:
        nu0 *= 1e9
        x0=h*nu0/(k_B*temp)
        dBdT0 = x0**4 * np.exp(x0) / (np.exp(x0)-1)**2.
        return  dBdT / dbdT0
    else:
        return dBdT

def fn_BnuT(nu, temp = 2.725):
    if nu<1e4: nu *= 1e9
    x=h*nu/(k_B*temp)

    t1 = 2 * h * nu**3./ c**2.
    t2 = 1./ (np.exp(x)-1.)

    return t1 * t2

def coth(x):
    return (np.exp(x) + np.exp(-x)) / (np.exp(x) - np.exp(-x))

def compton_y_to_delta_Tcmb(freq1, freq2 = None, Tcmb = 2.73):

    """ad
    c.f:  table 1, sec. 3 of arXiv: 1303.5081; 
    table 8 of http://arxiv.org/pdf/1303.5070.pdf
    no relativistic corrections included.
    freq1, freq2 = frequencies in GHz to cover the bandpass
    freq2 = None will force freq1 to be the centre frequency
    """

    if freq1<1e4: freq1 = freq1 * 1e9

    if not freq2 is None:
        if freq2<1e4: freq2 = freq2 * 1e9
        freq = np.arange(freq1,freq2,delta_nu)
    else:
        freq = np.asarray([freq1])

    x = (h * freq) / (k_B * Tcmb)
    g_nu = x * coth(x/2.) - 4.

    return Tcmb * np.mean(g_nu)

def get_cl_dust(freq1, freq2, fg_model = 'george15', freq0 = 150, spec_index_dg_po = 1.505 - 0.077, spec_index_dg_clus = 2.51-0.2, Tcib = 20.):
    if fg_model == 'george15':
        el, cl_dg_po_freq0 = get_foreground_power_spt('DG-Po', freq1 = freq0, freq2 = freq0)
        el, cl_dg_clus_freq0 = get_foreground_power_spt('DG-Cl', freq1 = freq0, freq2 = freq0)
        el_norm = 3000

    #conert to Dls
    dl_fac = el * (el+1)/2/np.pi
    dl_dg_po = dl_fac * cl_dg_po_freq0
    dl_dg_clus = dl_fac * cl_dg_clus_freq0

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    bnu1 = fn_BnuT(freq1, temp = Tcib)
    bnu2 = fn_BnuT(freq2, temp = Tcib)
    bnu0 = fn_BnuT(freq0, temp = Tcib)

    etanu1_dg_po = ((1.*freq1*1e9)**spec_index_dg_po) * bnu1
    etanu2_dg_po = ((1.*freq2*1e9)**spec_index_dg_po) * bnu2
    etanu0_dg_po = ((1.*freq0*1e9)**spec_index_dg_po) * bnu0

    etanu1_dg_clus = ((1.*freq1*1e9)**spec_index_dg_clus) * bnu1
    etanu2_dg_clus = ((1.*freq2*1e9)**spec_index_dg_clus) * bnu2
    etanu0_dg_clus = ((1.*freq0*1e9)**spec_index_dg_clus) * bnu0

    dl_dg_po = dl_dg_po[el == el_norm][0] * epsilon_nu1_nu2 * (1.*etanu1_dg_po * etanu2_dg_po/etanu0_dg_po/etanu0_dg_po) * (el*1./el_norm)**2
    dl_dg_clus = dl_dg_clus[el == el_norm][0] * epsilon_nu1_nu2 * (1.*etanu1_dg_clus * etanu2_dg_clus/etanu0_dg_clus/etanu0_dg_clus) * (el*1./el_norm)**0.8

    cl_dg_po = dl_dg_po / dl_fac
    cl_dg_clus = dl_dg_clus / dl_fac

    cl_dg_po[np.isnan(cl_dg_po)] = 0.
    cl_dg_clus[np.isinf(cl_dg_clus)] = 0.

    return el, cl_dg_po, cl_dg_clus

def get_cl_tsz(freq1, freq2, freq0 = 150, fg_model = 'george15'):

    if fg_model == 'george15':
        el, cl_tsz_freq0 = get_foreground_power_spt('tSZ', freq1 = freq0, freq2 = freq0)

    tsz_fac_freq0 = compton_y_to_delta_Tcmb(freq0*1e9)
    tsz_fac_freq1 = compton_y_to_delta_Tcmb(freq1*1e9)
    tsz_fac_freq2 = compton_y_to_delta_Tcmb(freq2*1e9)

    scalefac = tsz_fac_freq1 * tsz_fac_freq2/ (tsz_fac_freq0**2.)

    cl_tsz = cl_tsz_freq0 * scalefac
    cl_tsz[np.isnan(cl_tsz)] = 0.
    cl_tsz[np.isinf(cl_tsz)] = 0.

    return el, cl_tsz

def get_cl_tsz_cib(freq1, freq2, freq0 = 150, fg_model = 'george15', spec_index_dg_po = 1.505 - 0.077, spec_index_dg_clus = 2.51-0.2, Tcib = 20.):

    if fg_model == 'george15':
        corr_coeff = 0.1
    elif fg_mode == 'reichardt20':
        corr_coeff = 0.078

    el, cl_dg_po_freq1_freq1, cl_dg_clus_freq1_freq1 = get_cl_dust(freq1, freq1, freq0 = freq0, fg_model = fg_model, spec_index_dg_po = spec_index_dg_po, spec_index_dg_clus = spec_index_dg_clus, Tcib = Tcib)
    el, cl_tsz_freq1_freq1 = get_cl_tsz(freq1, freq1, freq0 = freq0, fg_model = fg_model)
    cl_dg_freq1_freq1 = cl_dg_po_freq1_freq1 + cl_dg_clus_freq1_freq1

    el, cl_dg_po_freq2_freq2, cl_dg_clus_freq2_freq2 = get_cl_dust(freq2, freq2, freq0 = freq0, fg_model = fg_model, spec_index_dg_po = spec_index_dg_po, spec_index_dg_clus = spec_index_dg_clus, Tcib = Tcib)
    el, cl_tsz_freq2_freq2 = get_cl_tsz(freq2, freq2, freq0 = freq0, fg_model = fg_model)
    cl_dg_freq2_freq2 = cl_dg_po_freq2_freq2 + cl_dg_clus_freq2_freq2

    cl_tsz_cib = corr_coeff * ( np.sqrt(cl_tsz_freq1_freq1 * cl_dg_freq2_freq2) + np.sqrt(cl_tsz_freq2_freq2 * cl_dg_freq1_freq1) )

    return el, cl_tsz_cib

def get_cl_radio(freq1, freq2, freq0 = 150, fg_model = 'george15', spec_index_rg = -0.9):

    if fg_model == 'george15':
        el, cl_rg_freq0 = get_foreground_power_spt('RG', freq1 = freq0, freq2 = freq0)
        el_norm = 3000

    #conert to Dls
    dl_fac = el * (el+1)/2/np.pi
    dl_rg = dl_fac * cl_rg_freq0

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    dl_rg = dl_rg[el == el_norm][0] * epsilon_nu1_nu2 * (1.*freq1 * freq2/freq0/freq0)**spec_index_rg * (el*1./el_norm)**2

    cl_rg = dl_rg / dl_fac

    cl_rg[np.isnan(cl_rg)] = 0.

    return el, cl_rg


#def get_cl_cib_websky(freq1, freq2, units = 'uk', websky_scaling_power = 0.75**2., el = None):
def get_cl_cib_websky(freq1, freq2, units = 'uk', websky_scaling_power = 1., el = None):
    websky_freq_dic = {90: 93, 93: 93, 95: 93, 143: 145, 145: 145, 150: 145, 217: 217, 220: 217, 225: 217, 545: 545, 600: 545, 857: 857}
    fname = '/Users/sraghunathan/Research/SPTPol/analysis/git/DRAFT/data/websky/cl_websky_cib_masked.npy'
    websky_freq1 = websky_freq_dic[freq1]
    websky_freq2 = websky_freq_dic[freq2]
    cl_cib = np.load(fname, allow_pickle = 1, encoding = 'latin1').item()['cl_dic'][(websky_freq1, websky_freq2)]
    if units.lower() == 'k':
        cl_cib /= 1e12
    cl_cib *= websky_scaling_power

    el_cib = np.arange( len(cl_cib) )
    if el is not None:
        cl_cib = np.interp(el, el_cib, cl_cib, left = 0., right = 0.)
        el_cib = np.copy( el )

    return el_cib, cl_cib

def get_cl_cib_mdlp2(freq1, freq2, units = 'uk', el = None):

    #conversion factors: Kcmb-to-Mjy/Sr for maps
    #mdplp2_spt_conv = {90: 221.832, 150: 394.862, 220: 468.451}
    mdplp2_freq_dic = {90: 90, 93: 90, 95: 90, 143: 150, 145: 150, 150: 150, 217: 220, 220: 220, 225: 220, 545: 545, 600: 545, 857: 857}
    mdlp2_freq1 = mdplp2_freq_dic[freq1]
    mdlp2_freq2 = mdplp2_freq_dic[freq2]
    mdplp2_conv = {90: 248.173, 150: 426.433, 220: 529.49, 545: 57.6963, 857: 2.26476}

    exp_freq_dic = {90: 'spt', 150: 'spt', 220: 'spt', 100: 'planck', 143: 'planck', 217: 'planck', 353: 'planck', 545: 'planck', 600: 'planck', 857: 'planck'}
    fd = '/Users/sraghunathan/Research/SPTPol/analysis/git/DRAFT/data/MDLP2_CIB/'
    fname = '%s/cls_mdpl2_%s%03d_%s%03d_lensed.dat' %(fd, exp_freq_dic[freq1], mdlp2_freq1, exp_freq_dic[freq2], mdlp2_freq2)

    cl_cib = np.loadtxt(fname)#/(2.73**2.)
    cl_cib = cl_cib[:4096]
    if units.lower() == 'k':
        cl_cib /= 1e12

    conv1  = 1./mdplp2_conv[mdlp2_freq1]
    conv2 = 1./mdplp2_conv[mdlp2_freq2]
    conv = np.sqrt(conv1 * conv2)**2.
    cl_cib *= conv

    el_cib = np.arange( len(cl_cib) )
    if el is not None:
        cl_cib = np.interp(el, el_cib, cl_cib, left = 0., right = 0.)
        el_cib = np.copy( el )

    return el_cib, cl_cib
    
def get_cl_galactic(param_dict, component, freq1, freq2, which_spec, which_gal_mask = 0, bl_dic = None, el = None):

    #fix: pol not working yet

    #https://healpy.readthedocs.io/en/1.5.0/generated/healpy.sphtfunc.anafast.html#healpy.sphtfunc.anafast
    spec_inds_dic = { 'TT':0, 'EE':1, 'BB':2, 'TE':3, 'EB':4, 'TB':5} #py2

    assert component in ['dust', 'sync']

    try:
        which_gal_mask = param_dict['which_gal_mask']
    except:
        pass

    if component == 'dust':
        cl_gal_dic_fname = param_dict['cl_gal_dic_dust_fname']
    elif component == 'sync':
        cl_gal_dic_fname = param_dict['cl_gal_dic_sync_fname']

    try:
        cl_gal_folder = param_dict['cl_gal_folder']
        cl_gal_dic_fname = '%s/%s' %(cl_gal_folder, cl_gal_dic_fname)
    except:
        pass

    if (0):##component == 'sync':
        #fix me: Forcing sync. to CUmilta's simulations
        print('\n\t\tForcing sync. to CUmilta\'s simulations\n\n')
        try:
            cl_gal_dic_fname = param_dict['cl_gal_dic_sync_fname_forced']
        except:
            pass

    cl_gal_dic = np.load(cl_gal_dic_fname, allow_pickle = 1, encoding = 'latin1').item()['cl_dic'][which_gal_mask]

    try:
        cl_gal = cl_gal_dic[ (freq1, freq2) ]
    except:
        cl_gal = cl_gal_dic[ (freq2, freq1) ]

    #pick the requested spectra: TT, EE, BB, TE, EB, TB.
    spec_ind = spec_inds_dic[which_spec]

    #fix me
    if np.ndim(cl_gal) == 1: #TT-only. Pol will fail.
        cl_gal = np.asarray( [cl_gal] )

    ############################################################################################################
    ############################################################################################################
    ############################################################################################################
    #compare EE at \ell = 80 to table 1 of https://arxiv.org/pdf/1801.04945.pdf
    if (0):##which_spec == 'EE' and component == 'dust' and freq1 == 145 and freq1 == freq2: 
        freq0 = 353.
        el_norm = 80.
        Tdust = 20. ##19.6
        Adust_freq0 = 4.3
        spec_index_dust = 1.54 ##1.6
        nr = ( fn_dB_dT(freq0) )**2.
        dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

        epsilon_nu1_nu2 = nr/dr

        bnu1 = fn_BnuT(freq1, temp = Tdust)
        bnu2 = fn_BnuT(freq2, temp = Tdust)
        bnu0 = fn_BnuT(freq0, temp = Tdust)

        etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
        etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
        etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0    
        cl_ee = cl_gal_dic[ (freq1, freq2) ][1]
        mul_fac = epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust)
        print(mul_fac)
        print(component, freq1, freq2, cl_ee[80], cl_ee[80] / mul_fac)
        loglog(cl_ee); xlim(None, 200.); ylim(1e-6, 1e-2)
        sys.exit()
    ############################################################################################################
    ############################################################################################################
    ############################################################################################################

    if which_spec == 'TE' and cl_gal_dic_fname.find('CUmilta')==-1:
        #force TE to be np.sqrt(TT) * np.sqrt(EE)
        ###cl_gal = np.sqrt( cl_gal[0] * cl_gal[1] )
        cl_gal_tt, cl_gal_ee = cl_gal_dic[ (freq1, freq2) ][0], cl_gal_dic[ (freq1, freq2) ][1]

        if (1):##component == 'dust':
            rte = 0.35 #page 5 of https://arxiv.org/pdf/1801.04945.pdf: Discussion below Fig.5; also page 38 of https://readthedocs.org/projects/so-pysm-models/downloads/pdf/0.2.dev/
        else: ##elif component == 'sync':
            rte = 0.
        cl_gal = rte * np.sqrt( cl_gal_tt * cl_gal_ee )

        '''
        if (0):##component == 'sync':
            rho_dust_sync = 0.16 #Fig. 8 of https://arxiv.org/pdf/1801.04945.pdf
            cl_gal = cl_gal * rho_dust_sync

        if (0):#component == 'dust':   
            print('TE dust: scaling',)         
            ##cl_gal_old = np.copy(cl_gal)
            freq0 = 278
            rte = 0.35 
            cl_gal_tt, cl_gal_ee = cl_gal_dic[ (freq0, freq0) ][0], cl_gal_dic[ (freq0, freq0) ][1]
            cl_gal_freq0 = rte * np.sqrt( cl_gal_tt * cl_gal_ee )
            cl_gal = scale_cl_dust_galactic(cl_gal_freq0, freq1, freq2, freq0 = freq0)#, Tdust = 19.6, spec_index_dust = 1.6)

            if (0):
                color_dic = {93: 'b', 145: 'green', 225: 'orangered', 278: 'darkred'} 
                ls_dic = {93: ':', 145: '--', 225: '-.', 278: '-'} 
                loglog(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
                legend(loc = 3, fontsize = 8)
            if (0):
                loglog(cl_gal_old, 'k', ls = '-')
                loglog(cl_gal, color = 'orangered', ls ='--')
                title(r'%s: %s: %s,%s' %(component, which_spec, freq1, freq2))
                show()

            if (0):###freq1 != freq2:
                print('TE dust: nulling cross terms',)
                cl_gal *= 0.
        
        if (0):#component == 'sync':
            print('TE sync: nulling',)
            cl_gal *= 0.
        '''

        """
        else:
            '''
            if which_gal_mask == 3:
                ee_te_ratio = 5.
            else:
                ee_te_ratio = 2.7
            '''
            ee_te_ratio = 2.7
            spec_ind = 1 ##EE
            cl_gal = cl_gal_dic[ (freq1, freq2) ][spec_ind] * ee_te_ratio  
        loglog(cl_gal)
        loglog(cl_gal_dic[ (freq1, freq2) ][1] * 2.7)
        show();sys.exit()
        """
    else:
        try:
            cl_gal = cl_gal[spec_ind]
        except:
            print('(%s,%s) not found for mask = %s in %s. Setting them to zeros.' %(freq1, freq2, which_spec, cl_gal_dic_fname))
            cl_gal = np.zeros( len(cl_gal[0]) )

    if (0):##component == 'dust':
        color_dic = {93: 'b', 145: 'green', 225: 'orangered', 278: 'darkred'} 
        ls_dic = {93: ':', 145: '--', 225: '-.', 278: '-'}
        if which_spec == 'TT':
            ax = subplot(1,3,1, yscale = 'log')
            legend(loc = 3, fontsize = 4, ncol = 3)
            plot(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
            xlim(0., 7000.); ylim(1e-8, 1e7)
        elif which_spec == 'EE':
            ax = subplot(1,3,2, yscale = 'log')
            plot(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
            xlim(0., 7000.); ylim(1e-8, 1e7)
        elif which_spec == 'TE':
            ax = subplot(1,3,3, yscale = 'log')
            plot(cl_gal, color = color_dic[freq1], ls = ls_dic[freq2], label = r'%s,%s' %(freq1, freq2))
            xlim(0., 7000.); ylim(1e-8, 1e7)

    el_gal = np.arange( len(cl_gal) )

    if bl_dic is not None:
        bl1 = bl_dic[freq1]
        bl2 = bl_dic[freq2]

        if len(bl1) != len(cl_gal): #adjust array lengths first
            el_tmp = np.arange( len(bl1) )
            cl_gal = np.interp(el_tmp, el_gal, cl_gal, left = 0., right = 0.)
            el_gal = np.copy( el_tmp )

        cl_gal = cl_gal / (bl1 * bl2)

    if el is not None:
        cl_gal = np.interp(el, el_gal, cl_gal, left = 0., right = 0.)
        el_gal = np.copy( el )

    return el_gal, cl_gal

def dB_dt_new(freq, tcmb = 2.725):

    h, k_B, c=6.626e-34,1.38e-23, 3e8

    x = (h/k_B)*(freq*1e9/tcmb)
    t1 = 2 * (h/c/tcmb)**2. * (1/k_B) * (freq*1e9)**4
    t2 = np.exp(x) / (np.exp(x) - 1)**2.

    dB_dt = t1 * t2 * 1e26

    return dB_dt

def lagache_scalings(cl, freq1, freq2, freq0):


    if freq1 == 90: freq1 = 95
    if freq2 == 90: freq2 = 95

    if freq1 == 600: freq1 = 545
    if freq2 == 600: freq2 = 545

    conv_MJyperSr_Kcmb_dic_spt_spire = {95: 234.042, 150: 413.540, 220: 477.017, 857: 2.124, 545: 42.275, 600: 41.275}

    sed_conv = {(95, 150): 0.2553, (95, 220): 0.08713, (150, 220): 0.3413, (857, 95): 294.03, (857, 150): 75.08, (857, 220): 25.62, (545, 95): 147.85, (545, 150): 37.75, (545, 220): 12.88}

    conv1 = conv_MJyperSr_Kcmb_dic_spt_spire[freq1]
    conv2 = conv_MJyperSr_Kcmb_dic_spt_spire[freq2]
    conv0 = conv_MJyperSr_Kcmb_dic_spt_spire[freq0]

    if (freq1, freq0) in sed_conv:
        sed_conv1 = sed_conv[(freq1, freq0)]
    elif (freq0, freq1) in sed_conv:
        sed_conv1 = 1./sed_conv[(freq0, freq1)]
    elif freq1 == freq0:
        sed_conv1 = 1.

    if (freq2, freq0) in sed_conv:
        sed_conv2 = sed_conv[(freq2, freq0)]
    elif (freq0, freq2) in sed_conv:
        sed_conv2 = 1./sed_conv[(freq0, freq2)]
    elif freq2 == freq0:
        sed_conv2 = 1.

    #print(freq1, freq2, freq0, conv1, conv2, conv0, sed_conv1, sed_conv2)
    #sys.exit()

    scaled_cl =  cl * (conv0/conv0/conv1*conv2) * ((sed_conv1*sed_conv2))

    return scaled_cl

def scale_cl_dust_galactic(cl, freq1, freq2 = None, freq0 = 278., Tdust = 19.6, spec_index_dust = 1.6):

    if freq2 is None:
        freq2 = freq1

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    if (0):
        t1 = dB_dt_new(freq0)
        t2 = dB_dt_new(freq1)
        nr = t1**2.
        dr = t2**2.
        epsilon_nu1_nu2 = nr/dr

        print(t1, t2, epsilon_nu1_nu2)

        sys.exit()

    bnu1 = fn_BnuT(freq1, temp = Tdust)
    bnu2 = fn_BnuT(freq2, temp = Tdust)
    bnu0 = fn_BnuT(freq0, temp = Tdust)

    etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
    etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
    etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0

    cl_dust = cl * epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust)## * (el*1./el_norm)**el_slope

    return cl_dust

def get_cl_dust_galactic(el, freq1, freq2 = None, freq0 = 353., el_norm = 80., el_slope = -0.58, Tdust = 19.6, Adust_freq0 = 4.3, spec_index_dust = 1.6, return_dl = 0):

    if freq2 is None:
        freq2 = freq1

    nr = ( fn_dB_dT(freq0) )**2.
    dr = fn_dB_dT(freq1) * fn_dB_dT(freq2)

    epsilon_nu1_nu2 = nr/dr

    bnu1 = fn_BnuT(freq1, temp = Tdust)
    bnu2 = fn_BnuT(freq2, temp = Tdust)
    bnu0 = fn_BnuT(freq0, temp = Tdust)

    etanu1_dust = ((1.*freq1*1e9)**spec_index_dust) * bnu1
    etanu2_dust = ((1.*freq2*1e9)**spec_index_dust) * bnu2
    etanu0_dust = ((1.*freq0*1e9)**spec_index_dust) * bnu0

    dl_dust = Adust_freq0 * epsilon_nu1_nu2 * (1.*etanu1_dust * etanu2_dust/etanu0_dust/etanu0_dust) * (el*1./el_norm)**el_slope

    if return_dl:
        return dl_dust
    else:
        dl_fac = el * (el+1)/2/np.pi
        cl_dust = dl_dust / dl_fac
    return cl_dust

"""
els = np.arange(1,100)
elval = 80.
Adust_90 = fn_dust_amp(elval, 90.)
Adust_150 = fn_dust_amp(elval, 150.)
Adust_220 = fn_dust_amp(elval, 220.)

#cl_dust_150 = fn_dust_amp(elval, 90.)

print(Adust_90, Adust_150, Adust_220)
"""

